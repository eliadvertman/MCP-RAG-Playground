# Story 1.3: Implement Basic Health Checks for Core Services

**Story ID:** 1.3  
**Epic:** Critical Architecture Remediation - Foundation (Epic 1)  
**Status:** Draft  
**Priority:** High  
**Story Points:** 3  

## Story Statement

**As a** platform engineer deploying MCP RAG Playground  
**I want** health check endpoints for all critical services  
**So that** I can monitor system health and implement proper production deployment patterns  

## Background Context

This is a **brownfield enhancement story** that adds production-readiness capabilities to the existing MCP RAG Playground system. Currently, there are no standardized health monitoring mechanisms, making production deployment and operational monitoring impossible.

**Current State:**
- No health check endpoints or monitoring interfaces
- Individual components have `test_connection()` methods but no unified health service
- Zero production deployment capability due to missing operational patterns
- No standardized way to verify system readiness

**Business Impact:**
- Enables production deployment patterns (Kubernetes readiness/liveness probes)
- Provides operational visibility for 99.9% uptime targets
- Standardizes monitoring interface for enterprise adoption

## Acceptance Criteria

1. **Health Service Module**: Create centralized health monitoring service
2. **Component Health Checks**: Leverage existing `test_connection()` methods for core components
3. **Health Endpoints**: Implement `/health` endpoints compatible with container orchestration
4. **Service Status**: Provide detailed status for Milvus, embeddings, and MCP server
5. **Non-Intrusive Design**: Monitoring adds minimal overhead to existing operations
6. **Configuration**: Health check intervals and timeouts configurable via environment
7. **Integration**: Works with existing DI container patterns

## Dev Notes

### **Previous Story Context**
**Dependencies:** 
- Story 1.1 (Import Chain Fix) - Required for clean module exports
- Story 1.2 (Factory Methods) - Health service will use factory patterns

### **Current Architecture Analysis** 
**Source: [milvus_client.py, vector_client.py, architecture-analysis.md]**

**Existing Health Check Methods:**
```python
# MilvusVectorDB.test_connection() - Line 208-224
def test_connection(self) -> bool:
    """Test the connection to Milvus."""
    try:
        from pymilvus import utility
        self.connect()
        utility.list_collections()  # Test operation
        return True
    except Exception as e:
        logger.error(f"Milvus connection test failed: {e}")
        return False

# VectorClient.test_connection() - Line 188-200  
def test_connection(self) -> bool:
    """Test the connection to the vector database."""
    return self.vector_db.test_connection()
```

**Current Component Structure:**
- **Milvus**: Has direct connection testing via `test_connection()`
- **Embedding Service**: No explicit health check, but model loading can be verified
- **Document Processor**: File system operations, basic validation possible
- **MCP Server**: FastMCP framework, connection status verifiable

### **Technical Implementation Strategy**
**Source: [architecture-analysis.md - Health Monitoring Layer]**

**Proposed Health Module Structure:**
```
mcp_rag_playground/
├── monitoring/
│   ├── __init__.py          # Health check exports
│   ├── health_service.py    # Core health status checking
│   ├── endpoints.py         # FastAPI health endpoints (/health)
│   └── models.py           # Health status data models
```

**Health Check Design Pattern:**
```python
# Non-intrusive monitoring leveraging existing test_connection() methods
class HealthService:
    def __init__(self, container: Container):
        self.container = container  # Uses existing DI
    
    async def check_milvus_health(self) -> HealthStatus:
        vector_db = self.container.vector_db()
        return await vector_db.test_connection()
```

### **File Locations**
**Source: [architecture-analysis.md - enhancement design]**

**New Files to Create:**
- `mcp_rag_playground/monitoring/__init__.py`
- `mcp_rag_playground/monitoring/health_service.py`
- `mcp_rag_playground/monitoring/endpoints.py`
- `mcp_rag_playground/monitoring/models.py`

**Files to Update:**
- `mcp_rag_playground/__init__.py` - Add health monitoring exports
- `mcp_rag_playground/mcp/rag_server.py` - Integrate health endpoints

### **Health Check Components**
**Source: [milvus_client.py, SentenceTransformerEmbedding, DocumentProcessor]**

**Component Health Verification:**
1. **Milvus Connection**: Use existing `MilvusVectorDB.test_connection()`
2. **Embedding Service**: Verify model loading and basic embedding operation
3. **Document Processing**: Test file system access and basic processing
4. **MCP Server**: Verify FastMCP server status and tool availability

**Health Status Information:**
- Component status: UP/DOWN/DEGRADED
- Response time measurements
- Error messages for failed checks
- Timestamp of last successful check
- Service dependencies and their status

### **Integration Requirements**
**Source: [mcp/rag_server.py - FastMCP patterns, container/container.py]**

**FastMCP Integration:**
- Add health endpoints to existing FastMCP server
- Use existing MCP server lifecycle for health service management
- Maintain existing logging patterns with structured health data

**Container Integration:**
- Health service should use existing DI container for component access
- Maintain singleton patterns for consistency
- No impact on existing component initialization

### **Configuration Requirements**
**Source: [config/milvus_config.py patterns]**

**Environment Variables:**
- `HEALTH_CHECK_INTERVAL` - How often to run background checks
- `HEALTH_CHECK_TIMEOUT` - Timeout for individual component checks  
- `HEALTH_ENDPOINT_ENABLED` - Enable/disable health endpoints
- `HEALTH_LOG_LEVEL` - Logging level for health check operations

## Tasks / Subtasks

### **Task 1: Create Health Monitoring Module Structure** (AC: 1)
- Create `mcp_rag_playground/monitoring/` directory
- Implement `__init__.py` with health service exports
- Define health status data models in `models.py`
- **Reference:** [Source: architecture-analysis.md - Health Monitoring Layer]

### **Task 2: Implement Health Service Core Logic** (AC: 2, 4, 5)
- Create `health_service.py` with centralized health checking
- Implement individual component health checks using existing methods
- Add async health checking with configurable timeouts
- Integrate with existing DI container for component access
- **Reference:** [Source: milvus_client.py - test_connection methods]

### **Task 3: Add Milvus Health Verification** (AC: 2, 4)
- Leverage existing `MilvusVectorDB.test_connection()` method
- Add connection latency measurement
- Handle connection failures gracefully with error details
- **Reference:** [Source: milvus_client.py:208-224]

### **Task 4: Add Embedding Service Health Check** (AC: 2, 4)
- Verify SentenceTransformer model availability
- Test basic embedding operation with sample text
- Check model loading status and memory usage
- **Reference:** [Source: SentenceTransformerEmbedding class]

### **Task 5: Add Document Processor Health Check** (AC: 2, 4)
- Verify file system access capabilities
- Test basic document processing with sample content
- Check supported file type handlers availability
- **Reference:** [Source: DocumentProcessor class patterns]

### **Task 6: Implement Health Endpoints** (AC: 3, 6)
- Create `endpoints.py` with FastAPI health route handlers
- Implement `/health` endpoint returning overall system status
- Add `/health/detailed` endpoint with component-level details
- Support JSON response format for machine readability
- **Reference:** [Source: mcp/rag_server.py - FastMCP patterns]

### **Task 7: Integrate with MCP Server** (AC: 3, 7)
- Add health endpoints to existing FastMCP server
- Use existing server lifecycle for health service initialization
- Maintain existing logging and error handling patterns
- **Reference:** [Source: mcp/rag_server.py - FastMCP server setup]

### **Task 8: Add Configuration Support** (AC: 6)
- Add environment variable support for health check settings
- Implement configurable timeouts and intervals
- Add configuration validation and defaults
- **Reference:** [Source: config/milvus_config.py - environment patterns]

### **Task 9: Create Health Check Tests** (AC: 1-7)
- Test individual component health checks
- Test health service integration with container
- Test health endpoints response formats
- Test configuration parameter handling
- Mock external dependencies for unit testing
- **Reference:** [Source: CLAUDE.md - pytest patterns]

### **Task 10: Update Module Exports** (AC: 7)
- Add health monitoring to main `__init__.py` exports
- Update factory methods to include health service creation
- Ensure health service works with existing factory patterns
- **Reference:** [Source: Story 1.2 - factory patterns]

## Definition of Done

- [ ] Health monitoring module created with proper structure
- [ ] Health service implements checks for all core components
- [ ] `/health` endpoint returns overall system status
- [ ] `/health/detailed` endpoint provides component-level information
- [ ] All health checks leverage existing `test_connection()` methods
- [ ] Health service integrates with existing DI container
- [ ] Health endpoints added to existing MCP server
- [ ] Configuration support via environment variables
- [ ] Comprehensive test suite for all health checking functionality
- [ ] Health checks add minimal overhead (<10ms per check)
- [ ] Error handling and logging follow existing patterns
- [ ] Documentation with health endpoint API specification

## Notes

**Brownfield Considerations:**
- Must use existing component interfaces (`test_connection()` methods)
- No changes to core component behavior or initialization
- Health checks should be optional and non-blocking
- Maintain existing logging and error handling patterns

**Production Requirements:**
- Health endpoints must be compatible with Kubernetes probes
- Response format should be machine-readable (JSON)
- Individual component failures should not crash health service
- Health data should be cacheable to reduce check frequency

**Performance Considerations:**
- Health checks should run asynchronously
- Results should be cached with configurable TTL
- Heavy operations (like embedding tests) should be throttled
- Background health checking should not impact main operations

**Risk Mitigation:**
- Test health checks with both healthy and unhealthy components
- Verify health endpoints work under load
- Ensure health service doesn't create circular dependencies
- Test configuration edge cases and invalid values

---

**Story Created:** 2025-08-10  
**Source Requirements:** Project Brief MVP Scope - Basic Health Checks  
**Architecture Context:** milvus_client.py test_connection methods, monitoring design  
**Dependencies:** Story 1.1 (Import Fix), Story 1.2 (Factory Methods)