# Story 1.2: Implement Factory Methods for Core Components

**Story ID:** 1.2  
**Epic:** Critical Architecture Remediation - Foundation (Epic 1)  
**Status:** Draft  
**Priority:** High  
**Story Points:** 5  

## Story Statement

**As a** developer integrating MCP RAG Playground  
**I want** convenient factory methods to create core components  
**So that** I can set up the system with minimal boilerplate code instead of manual DI container usage  

## Background Context

This is a **brownfield enhancement story** that addresses the missing developer experience layer in the existing MCP RAG Playground system. Currently, developers must manually instantiate the DI container and call provider methods, requiring deep knowledge of the internal architecture.

**Current State:**
- Manual component instantiation requires understanding DI container internals
- No convenience methods like `create_rag_api()` or `create_vector_client()`
- 5x development time overhead for basic setup
- Copy-paste component instantiation across projects

**Business Impact:**
- 80% reduction potential in boilerplate setup code
- Improved developer adoption through better experience
- Standardized component creation patterns

## Acceptance Criteria

1. **Factory Module Created**: New `factories/` module with organized factory functions
2. **Core Factory Functions**: Implement `create_rag_api()`, `create_vector_client()`, and container access methods
3. **Pattern Consistency**: Factory methods leverage existing DI container under the hood
4. **Configuration Support**: Factory methods accept configuration parameters with sensible defaults
5. **Backward Compatibility**: Existing manual instantiation patterns continue working unchanged
6. **Documentation**: Clear examples and API documentation for factory usage
7. **Testing**: Comprehensive tests for all factory methods and configuration variations

## Dev Notes

### **Previous Story Context**
**Dependency:** Requires Story 1.1 (Import Chain Fix) to be completed first for clean module exports.

### **Current Architecture Analysis**
**Source: [container/container.py, architecture-analysis.md]**

**Existing DI Container Pattern:**
```python
# Current manual usage
from mcp_rag_playground.container.container import Container

container = Container()
rag_api = container.rag_api()
vector_client = container.vector_client()
```

**Container Components Available:**
- `milvus_config` - Singleton MilvusConfig.from_env
- `vector_db` - Singleton MilvusVectorDB with config
- `embedding_service` - Singleton SentenceTransformerEmbedding("all-MiniLM-L6-v2")
- `document_processor` - Singleton DocumentProcessor(chunk_size=800, overlap=200)
- `vector_client` - Singleton VectorClient with dependencies
- `rag_api` - Singleton RagAPI with vector_client

**Configuration Patterns:**
- Environment-based configuration via `MilvusConfig.from_env()`
- Hardcoded production defaults (model: "all-MiniLM-L6-v2", chunk_size: 800)
- Collection name providers using lambda functions

### **Technical Implementation Strategy**
**Source: [architecture-analysis.md - Enhancement Architecture Design]**

**Proposed Factory Layer Structure:**
```
mcp_rag_playground/
├── factories/
│   ├── __init__.py          # Public factory exports
│   ├── rag_factory.py       # create_rag_api(), RAG-specific factories
│   ├── vector_factory.py    # create_vector_client(), vector-specific factories
│   └── container_factory.py # get_container(), container access methods
```

**Design Pattern:**
- Wrap existing Container patterns with convenience methods
- Use existing DI container under the hood for consistency
- Support both default and custom configuration
- Maintain singleton behavior through container

### **File Locations**
**Source: [CLAUDE.md - Key Structure, enhancement design]**

**New Files to Create:**
- `mcp_rag_playground/factories/__init__.py`
- `mcp_rag_playground/factories/rag_factory.py`
- `mcp_rag_playground/factories/vector_factory.py`
- `mcp_rag_playground/factories/container_factory.py`

**Files to Update:**
- `mcp_rag_playground/__init__.py` - Add factory exports to __all__
- Documentation files with usage examples

### **Configuration Requirements**
**Source: [container/container.py, MilvusConfig]**

**Configurable Parameters:**
- Collection names (currently hardcoded: "prod_kb_collection", "prod_collection")
- Embedding model name (default: "all-MiniLM-L6-v2")
- Document processing settings (chunk_size: 800, overlap: 200)
- Milvus connection settings (via environment variables)

**Environment Variables:**
- Milvus configuration through existing `MilvusConfig.from_env()` pattern
- Should maintain existing environment variable support

### **Testing Requirements**
**Source: [CLAUDE.md - Testing section, container/container.py patterns]**

**Test Categories:**
- Factory method creation with default parameters
- Factory method creation with custom parameters
- Singleton behavior verification through container
- Integration with existing DI container
- Configuration parameter validation
- Environment variable integration testing

## Tasks / Subtasks

### **Task 1: Create Factory Module Structure** (AC: 1)
- Create `mcp_rag_playground/factories/` directory
- Implement `__init__.py` with public exports
- Set up module structure for different factory types
- **Reference:** [Source: architecture-analysis.md - Factory Layer]

### **Task 2: Implement RAG Factory Methods** (AC: 2, 4)
- Create `rag_factory.py` with `create_rag_api()` function
- Support custom collection names and configuration
- Leverage existing container.rag_api() implementation
- Add configuration validation and error handling
- **Reference:** [Source: container/container.py - rag_api provider]

### **Task 3: Implement Vector Client Factory Methods** (AC: 2, 4)
- Create `vector_factory.py` with `create_vector_client()` function
- Support custom embedding models and processing parameters
- Use existing container.vector_client() with custom config
- Handle configuration conflicts gracefully
- **Reference:** [Source: container/container.py - vector_client provider]

### **Task 4: Implement Container Access Methods** (AC: 2, 3)
- Create `container_factory.py` with public container access
- Implement `get_container()` function for advanced usage
- Provide access to individual container components
- Maintain existing singleton behavior
- **Reference:** [Source: container/container.py - Container class]

### **Task 5: Update Module Exports** (AC: 3, 6)
- Add factory functions to main `__init__.py` exports
- Update `__all__` list with new factory functions
- Ensure conditional export patterns work correctly
- **Reference:** [Source: Story 1.1 - module exports]

### **Task 6: Create Factory Tests** (AC: 7)
- Test factory methods with default parameters
- Test factory methods with custom configuration
- Verify singleton behavior through container
- Test integration with existing components
- Add configuration validation tests
- **Reference:** [Source: CLAUDE.md - pytest patterns]

### **Task 7: Add Usage Documentation** (AC: 6)
- Create clear examples showing factory usage vs manual instantiation
- Document configuration parameters and defaults
- Add migration guide from manual to factory patterns
- Update README with factory method examples

### **Task 8: Backward Compatibility Verification** (AC: 5)
- Run existing test suite to ensure no regressions
- Test existing manual instantiation patterns
- Verify container behavior remains unchanged
- Test import patterns from previous story
- **Reference:** [Source: Story 1.1 - backward compatibility]

## Definition of Done

- [ ] Factory module structure created with proper exports
- [ ] `create_rag_api()` function implemented and working
- [ ] `create_vector_client()` function implemented and working  
- [ ] Container access methods implemented
- [ ] All factory functions accept configuration parameters
- [ ] Factory functions leverage existing DI container
- [ ] Comprehensive test suite covering all factory methods
- [ ] Documentation with clear usage examples
- [ ] All existing tests pass without modification
- [ ] Factory functions exported in main module `__all__`
- [ ] Code review completed
- [ ] Performance impact assessed (should be minimal)

## Notes

**Brownfield Considerations:**
- Must maintain existing DI container behavior
- Factory methods should be thin wrappers over existing functionality
- No changes to core component implementations
- Preserve all existing configuration mechanisms

**Design Principles:**
- Convention over configuration with sensible defaults
- Clear separation between factory types (RAG, Vector, Container)
- Consistent parameter naming and validation
- Graceful error handling and meaningful error messages

**Risk Mitigation:**
- Test factory methods extensively with different configurations
- Verify no impact on existing container singleton behavior
- Ensure factory methods don't bypass container wiring
- Validate environment variable integration works correctly

---

**Story Created:** 2025-08-10  
**Source Requirements:** Project Brief MVP Scope - Factory Method Implementation  
**Architecture Context:** container/container.py, enhancement design patterns  
**Dependencies:** Story 1.1 (Import Chain Fix)